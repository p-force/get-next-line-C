Теперь вы начинаете понимать, что каждый раз, когда вы оказываетесь в ситуации чтения данных из file descriptor, и эти данные не имеют заранее известного размера, это сложно. Какой размер буфера выбрать ? Сколько раз читать файл descriptor, чтобы найти данные ?
Совершенно естественно и распространено в программировании желание прочитать “строку”
завершается переносом строки из файла descriptor. Например, каждая команда, которую вы вводите в своей оболочке, или каждая строка, прочитанная из плоского файла.
Благодаря проекту get_next_line вы сможете писать раз и навсегда
функция, позволяющая вам читать строку, завершенную новой строкой из файла descriptor, добавить ее в свой libft, если сердце говорит вам об этом, и, прежде всего, использовать ее во всех ваших последующих проектах, которые в ней нуждаются.

Этот проект не только позволит вам добавить очень удобную функцию в
вашей коллекции, но также позволит вам обратиться к удивительному новому элементу программирования на C: статические переменные.
Вы также будете испытывать более глубокие выделения, независимо от того, имеют ли они место
в стеке или в куче, манипуляции и жизненный цикл буфера, а также неожиданная сложность, связанная с использованием одной или нескольких статических переменных.
Конечно, вы также повысите свою строгость благодаря соблюдению стандарта,
но также, обнаружив, что начальное состояние переменной в функции может варьироваться от вызова этой функции к вызову...

Вы должны отображать только два файла: get_next_line.c и get_next_line.h • если вы умны и используете libft, также сделайте свою папку libft в корне рендеринга.
• В вашем рендеринге не должно быть главной функции. • Не делайте Makefile. • Ваш проект должен быть стандартным.
* Вы должны реагировать на ошибки. Ни в коем случае ваша программа (или в данном случае ваша функция) не должна неожиданно выходить из строя (сегментация fault, Bus error, double free и т. д.).
• Любая память, выделенная в куче, должна быть освобождена чисто, когда это необходимо.
• В корне репозитория рендеринга вы должны сделать файл автора, содержащий ваш логин, а затем ’\n’ :

Если вы решите визуализировать этот проект с помощью библиотеки libft, вам категорически запрещено добавлять в него функции, специфичные для вашего рендеринга get_next_line, чтобы обойти ограничения стандарта. это будет считаться обманом при защите. Ваш get_next_line должен соответствовать 5 функциям до 25 строк. Соблюдение этого предписания будет тщательно проверено на предмет защиты. Нет необходимости приходить к педаго спросить, является ли та или иная функция приемлемой, потому что вы хотите добавить ее в свою библиотеку. Спросите себя, нарушит ли ваша функция эту заповедь или нет, и используйте эту неприглядную вещь, расположенную на ваших плечах. Если вы придерживаетесь этого правила, вам, конечно, рекомендуется расширить свою библиотеку с помощью общих функций, которые вы обнаружите в ходе этого проекта.
* Разрешенными функциями libc в этом проекте являются read, malloc и free.

Напишите функцию, которая возвращает строку читать с file descriptor. • Называется “линия” последовательность символов, которая завершается ’\n’ (ascii-код 0x0a) или End Of File (EOF).


Первым параметром является file descriptor для чтения.
* Второй параметр-это адрес указателя на символ, который будет использоваться для хранения считываемой строки в File descriptor.
• возвращаемое значение может быть 1, 0 или -1 в зависимости от того, была ли прочитана строка, завершено ли чтение или произошла ошибка соответственно.
* Ваша функция get_next_line должна возвращать свой результат без ’\n'.
• Цикл вызова функции get_next_line, таким образом, будет читать доступный текст из дескриптора файла по одной строке за раз до конца текста, независимо от размера текста в вопросе или одной из его строк.
* Убедитесь, что ваша функция ведет себя хорошо при чтении из файла, стандартного ввода, перенаправления и т. д.
* Ваш файл get_next_line.h должен содержать хотя бы прототип функции get_next_line и макрос для выбора размера буфера чтения read. Это значение будет изменено на устойчивость, чтобы оценить надежность рендеринга. Этот макрос должен быть назван BUFF_SIZE.


Считается, что get_next_line имеет неопределенное поведение, если между двумя вызовами один и тот же файловый дескриптор обозначает два разных файла, в то время как чтение первого файла не было завершено.
• Также считается, что вызов функции lseek (2) никогда не будет выполняться между двумя вызовами get_next_line в одном файловом дескрипторе.
* Наконец, считается, что get_next_line имеет индетерминированное поведение при чтении в двоичном файле. Однако, если хотите, вы можете сделать это поведение последовательным.
* Глобальные переменные запрещены. * Статические переменные разрешены.